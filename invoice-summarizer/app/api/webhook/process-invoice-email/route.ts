import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { ChatOpenAI } from '@langchain/openai';
import { PromptTemplate } from '@langchain/core/prompts';
import { StringOutputParser } from '@langchain/core/output_parsers';

// Initialize Supabase client with service role key to bypass RLS
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Initialize OpenAI - Using same configuration as PDF processing
const llm = new ChatOpenAI({
  openAIApiKey: process.env.OPENAI_API_KEY,
  modelName: "gpt-3.5-turbo",
  temperature: 0.3,
});

// Email invoice processing prompt - Using the same detailed structure as PDF processing
const emailInvoicePrompt = PromptTemplate.fromTemplate(`
You are an AI assistant specialized in analyzing and summarizing invoices from email content. Please analyze the following email data and provide a comprehensive summary in JSON format.

Email Subject: {subject}
Email Body: {body}

Please provide a summary in the following JSON structure:
{{
  "summary": "A detailed 3-4 sentence summary of the invoice including key business context",
  "keyDetails": {{
    "vendor": "Name of the vendor/supplier/company that sent the invoice",
    "invoiceNumber": "Invoice number if found",
    "dueDate": "Due date if specified",
    "paymentTerms": "Payment terms if mentioned",
    "taxAmount": "Tax amount if specified",
    "subtotal": "Subtotal before tax if specified"
  }},
  "clientInfo": {{
    "name": "Company name of the vendor/supplier",
    "email": "Email address if found in the email",
    "company": "Full company name or business name",
    "address": "Company address if available",
    "phone": "Phone number if available"
  }},
  "lineItems": [
    {{
      "description": "Item description",
      "quantity": "Quantity",
      "unitPrice": "Unit price",
      "total": "Line total"
    }}
  ],
  "totalAmount": "Total invoice amount",
  "invoiceDate": "Invoice date in YYYY-MM-DD format if found",
  "currency": "Currency if specified",
  "notes": "Any additional notes, special instructions, or important business context",
  "businessContext": "Additional business context like project details, service period, or contract information"
}}

Important:
- Extract amounts as numbers only (no currency symbols)
- Use YYYY-MM-DD format for dates
- If any field is not found, use null
- Ensure all amounts are numeric values
- Extract the most accurate information available
- Focus on extracting the most important information that would be useful for accounting and business purposes
- Make sure to identify the vendor/company that sent the invoice and extract their contact information
- Analyze both the email subject and body for comprehensive information extraction
`);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { user_id, subject, body: emailBody } = body;

    if (!user_id || !subject || !emailBody) {
      return NextResponse.json(
        { error: 'Missing required fields: user_id, subject, body' },
        { status: 400 }
      );
    }

    // Process the email with LangChain - Using same chain approach as PDF processing
    const chain = emailInvoicePrompt.pipe(llm).pipe(new StringOutputParser());
    
    const result = await chain.invoke({
      subject,
      body: emailBody,
    });

    // Parse the JSON response
    let extractedData;
    try {
      extractedData = JSON.parse(result);
    } catch (parseError) {
      console.error('Failed to parse AI response as JSON:', parseError);
      // Fallback to a simple structure if parsing fails
      extractedData = {
        summary: result,
        keyDetails: {
          vendor: 'Unknown',
          invoiceNumber: 'Not specified',
          dueDate: 'Not specified',
          paymentTerms: 'Not specified',
          taxAmount: null,
          subtotal: null
        },
        clientInfo: {
          name: 'Unknown',
          email: null,
          company: 'Unknown',
          address: null,
          phone: null
        },
        lineItems: [],
        totalAmount: 'Unknown',
        invoiceDate: null,
        currency: 'USD',
        notes: 'Summary generated by AI',
        businessContext: null
      };
    }

    // Extract data from the detailed summary structure
    const { clientInfo, keyDetails, totalAmount, invoiceDate, summary } = extractedData;

    // Create or update client
    let clientId = null;
    if (clientInfo?.name || clientInfo?.email) {
      const { data: existingClient } = await supabase
        .from('clients')
        .select('id, total_amount, total_invoices')
        .eq('user_id', user_id)
        .eq('name', clientInfo.name || clientInfo.email)
        .single();

      if (existingClient) {
        // Update existing client
        const newTotal = (existingClient.total_amount || 0) + (totalAmount || 0);
        const newCount = (existingClient.total_invoices || 0) + 1;
        
        const { data: updatedClient } = await supabase
          .from('clients')
          .update({
            total_amount: newTotal,
            total_invoices: newCount,
            last_invoice: invoiceDate || new Date().toISOString().split('T')[0]
          })
          .eq('id', existingClient.id)
          .select()
          .single();
        
        clientId = existingClient.id;
      } else {
        // Create new client
        const { data: newClient } = await supabase
          .from('clients')
          .insert({
            user_id,
            name: clientInfo.name || clientInfo.email,
            email: clientInfo.email,
            company: clientInfo.company,
            status: 'active',
            total_invoices: 1,
            total_amount: totalAmount || 0,
            last_invoice: invoiceDate || new Date().toISOString().split('T')[0],
            created_at: new Date().toISOString()
          })
          .select()
          .single();
        
        clientId = newClient?.id;
      }
    }

    // Create invoice record (NO PDF storage for email invoices)
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        user_id,
        name: `Email Invoice - ${keyDetails?.invoiceNumber || 'Unknown'}`,
        client: clientInfo?.name || 'Unknown',
        client_id: clientId,
        date: invoiceDate || new Date().toISOString().split('T')[0],
        amount: totalAmount || 0,
        status: 'processed',
        source: 'email',
        summary: extractedData, // Store the full detailed summary object
        file_url: null, // No PDF for email invoices
        created_at: new Date().toISOString()
      })
      .select()
      .single();

    if (invoiceError) {
      console.error('Error creating invoice:', invoiceError);
      return NextResponse.json(
        { error: 'Failed to create invoice record' },
        { status: 500 }
      );
    }

    // Create email history record
    const { error: emailError } = await supabase
      .from('email_history')
      .insert({
        user_id,
        invoice_id: invoice.id,
        recipient: clientInfo?.email || 'Unknown',
        subject: subject,
        client: clientInfo?.name || 'Unknown',
        invoice_name: `Email Invoice - ${keyDetails?.invoiceNumber || 'Unknown'}`,
        status: 'delivered',
        date: new Date().toISOString().split('T')[0],
        time: new Date().toISOString().split('T')[1].split('.')[0],
        created_at: new Date().toISOString()
      });

    if (emailError) {
      console.error('Error creating email history:', emailError);
      // Don't fail the whole process for email history error
    }

    return NextResponse.json({
      success: true,
      message: 'Email invoice processed successfully',
      invoice_id: invoice.id,
      client_id: clientId
    });

  } catch (error) {
    console.error('Error processing email invoice:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
} 